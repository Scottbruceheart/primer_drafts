# Code Entropy is Technical Inflation

  Whenever we write software, the complexity of that software grows over time.  Adding featuers increases complexity in a greater than linear fashion.  Software engineers have a sense that 'going too fast' makes this much worse, in a way that is very expensive and error prone to repair. Most in the software industry call this 'technical debt'.  The correct term is 'technical inflation': it makes the unit effectiveness (purchasing power) of all future engineering input into the software system purchase less useful output. This matches well with the physics definition: hotter systems have more chaos and randomness, and are harder to get useful work done in. Call the idea that 'code that is written too fast or without proper regard to its scaling costs gets harder and harder to do useful work in' code entropy. The idea that code entropy is unavoidable also matches the physical analogue.

  In financial systems, debt is an obligation with an attached debt service payment and (often) duration the debt will exist. Debt is often packed into an asset that can be sold, traded, quantified, valued in dollars, and producing a positive income stream for the entity that holds it.  There are huge debt markets worldwide that trade in enormous classes of debt.  Taking out debt is often seen as a very positive action, providing access to future money early.  This early access to capital allows useful work to be done sooner with a well defined and precisely quantified (units of currency!) price.  The entity that provides the capital that comprises the debt benefits also: it gains some return from the risk of lending out its capital.

Inflation is loss in purchasing power of a unit of currency over time. It isn't well controlled, it has persistent negative effects, and reversing its impact is prohibitively expensive.

  Code entropy has none of the debt-like qualities: 'technical debt' as a metaphor falls down and causes bad choices to be made by engineering organizations.  The metaphor implies that the code entorpy has consistent and stable debt service (maintenance) cost.  The metaphor implies that code entropy does not interact with anything around it. THe metaphor implies code entropy can be slowly and incrementally reduced with something akin to an interest payment. The metaphor implies that every unit of engineering work applied to reducing code entropy gets exactly one unit (less interest) of reduction! The metaphor implies that you can choose not to take on code entropy!  In practice, none of these or any of the other implications are true.  Increasing code entropy results in higher defect rates, inconsistent and increasing maintenance burden, pervasive damage to most or all parts of a codebase, and the only optionality involved is how diligent you are about slowing the increase!

  Code entropy matches the inflation-like qualities! Each unit of 'entropic increase' makes each future unit of work put into the codebase less effective, forever. It is prohibitively expensive to reduce that entropic increase.  Why is reducing the entropy difficult? Refactors (even tool assisted) exceed the complexity that can be handled by a single person or small team.  We also speculate that once your refactor gets too large, the entropy added is less than the entropy removed.  Using tooling helps shift this threshold, but all tooling causes complexity increases of its own, so you have to be careful that your tooling is a net positive. As engineering organizations grow, making code entropy reducing changes gets harder and is less likely to be effective for at least two reasons.  People that are familiar enough with why the code was written a certain way and how to materially improve its design tend to leave organizations over time.  Individuals tend to focus on things that get them promoted or rewarded within an organization: they take actions that the incentive structure of the organization rewards. Most organizations usually incentivize growth over efficiency in most cases.  

'Going too fast' (for a given orgs 'skill envelope')  when implementing incurs extra code entropy costs.  Most organizations don't quite realize what a heavy cost they are incurring because they are using the wrong metaphor.  Uncomprehendingly, they do not receive enough benefit for the cost they incur, and the negatives of very high code entropy are very damaging to organization effectiveness.
 to the extent that they know spending some future time chasing and repairing bugs, reducing the complexity scaling cost of software or fire fighting errors and quality issues as what was sown is reaped.  (Make time for maintenance or maintenance will make time for you, as they say).   

We do not have a good solution to code entropy generation over time, but using inflation instead of debt is a much more accurate metaphor. Please use 'technical inflation' as the term of art when talking about this, so as to provide a more accurate vision to all our colleagues of what is actually occuring.
